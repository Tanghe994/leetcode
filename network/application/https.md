# Application Layer

---

## 模型划分

- OSI七层模型

  `应用层` `表示层` `会话层` `传输层` `网络层` `数据链路层` `物理层`

- TCP/IP模型概念

  `应用层` `传输层` `网络层` `数据链路层` `物理层`


- Reason：由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的， 这也就造成 OSI 设想中的应用程序维度的分层是无法实现的

---

## HTTP

- Q：头部信息？

  A：主要分为通用头部，请求头部，响应头部和实体头部

- Q：Keep-Alive 和非 Keep-Alive 区别？

  A：Keep-Alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流， 对于非 Keep=Alive 来说，必须为每一个请求的对象建立和维护一个全新的连接，不适合高并发的情况

- Q：HTTP 长连接短连接使用场景是什么？

  A：长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。 短连接：用户数目较多的Web网站的 HTTP
  服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。

- Q：HTTP 方法了解哪些？

  A： HTTP/1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。

      HTTP/1.1 增加了六种请求方法：OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。

  `GET`   请求指定的页面信息，并返回具体内容，通常只用于读取数据。

  `HEAD`  类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。

  `POST`  向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。

  `PUT`   替换指定的资源，没有的话就新增。

  `DELETE`    请求服务器删除 URL 标识的资源数据。

  `CONNECT`   将服务器作为代理，让服务器代替用户进行访问。

  `OPTIONS`   向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。

  `TRACE`     回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。

  `PATCH`     是对 PUT 方法的补充，用来对已知资源进行局部更新。

- Q：GET 和 POST 的区别？

  A：get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get
  方法，post 方法更安全，主要用于修改服务器上的资源。

  get 请求只支持 URL 编码，post 请求支持多种编码格式。

  get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。

  get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制

  get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。

  get 方法产生一个 TCP 数据包，post 方法产生两个（并不是所有的浏览器中都产生两个）

- Q：GET 的长度限制是多少？

  A：HTTP 中的 GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器； 由于 POST 方法请求参数在请求主体中，理论上讲，post
  方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。


- Q：HTTP 与 HTTPs 的工作方式【建立连接的过程】

  A：HTTP：HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是
  UDP）作为它的支撑运输层协议。 默认是80端口。

  HTTPS：HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP
  的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。 在连接握手的过程中需要验证SSL，默认是443端口

- Q：HTTPS 和 HTTP 的区别？

  A：HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。

  HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。

  HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。

  HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程

- Q：HTTPS 的加密方式？

  A：HTTPS 采用对称加密和非对称加密相结合的方式

- Q：HTTP 是不保存状态的协议,如何保存用户状态？

  A：一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议。

  有两种解决方案：

  1、基于Session 实现的会话保持

  在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中
  `优点`：安全性高，因为状态信息保存在服务器端

  2、基于 Cookie 实现的会话保持

  。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。
  `优点`：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。

  extra：Cookie被禁用了怎么办？

  若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。


- Q：状态吗？

  A：**1XX** 指示信息--表示请求正在处理，**2XX**成功--表示请求已被成功处理完毕，**3XX**重定向--要完成的请求需要进行附加操作，
  **4XX** 客户端错误--请求有语法错误或者请求无法实现，服务器无法处理请求， **5XX** 服务器端错误--服务器处理请求出现错误。

  301：永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI

  302：临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有URI

  404：not found

  414：请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务

  504：充当网关或代理的服务器，未及时从远端服务器获取请求

- Q：HTTP/1.1 和 HTTP/1.0 的区别？

  A：缓存处理：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，

  节约带宽：当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range
  头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发

  长连接：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，HTTP/1.1 默认使用的是持久连接。

- Q：HTTP/1.X 和 HTTP/2.0 的区别？

  A：相比于 HTTP/1.X 的文本（字符串）传送， HTTP/2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。

  HTTP/2.0 支持多路复用。因为流 ID 的存在， 通过同一个 HTTP 请求可以实现多个 HTTP 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。

  HTTP/2.0 头部压缩。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP
  传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。

  HTTP/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。


- Q：HTTP/3 了解吗？

  A：HTTP/2 存在的问题：传统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。 HTTP/2
  多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决。

  Http/3增加了QUIC协议，Quick UDP Internet Connections），直译为快速UDP网络连接，底层基于UDP传输，QUIC 复用了 HTTP/2 协议的多路复用功能。
  在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理,不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID.
  
![](https://pic.leetcode-cn.com/1612458489-HxhiPr-HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%98%E5%8C%96.png)

- Q:DNS的作用和原理？

  A：作用：能够进行主机名到 IP 地址转换的目录服务，域名系统作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网
  
  ![](https://pic.leetcode-cn.com/1612458680-mTSUQn-DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)
  
  根域名服务器、顶级域名服务器、权威域名服务器
    
  ![](https://pic.leetcode-cn.com/1612458718-QcTlwM-DNS.png)

  拓展：域名解析查询的两种方式

  递归查询：如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户端的身份，向其他根域名服务器继续发出查询请求报文，即替主机继续查询，而不是让主机自己进行下一步查询，如上图步骤（1）和（10）。

  迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应该找哪个域名服务器进行查询，然后让本地服务器进行后续的查询，如上图步骤（2）~（9）。


- Q:socket() 套接字有哪些?

  A：TCP 用主机的 IP 地址 + 端口号作为 TCP 连接的端点，这个端点就叫做套接字。

  套接字主要有以下三种类型：

  流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议，**主要用于提供面向连接、可靠的数据传输服务**。由于 TCP 协议的特点，使用流套接字进行通信时能够保证数据无差错、无重复传送，并按顺序接收，通信双方不需要在程序中进行相应的处理。

  数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议，对应于无连接的 UDP 服务应用。该服务并不能保证数据传输的可靠性，也无法保证对端能够顺序接收到数据。此外，通信两端不需建立长时间的连接关系，当 UDP 客户端发送一个数据给服务器后，其可以通过同一个套接字给另一个服务器发送数据。当用 UDP 套接字时，丢包等问题需要在程序中进行处理。

  原始套接字（SOCK_RAW）：由于流套接字和数据报套接字只能读取 TCP 和 UDP 协议的数据，当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。


- Q：URI（统一资源标识符）和 URL（统一资源定位符）之间的区别？

  A：从定义即可看出，URL 是 URI 的一个子集，两者都定义了资源是什么，而 URL 还定义了如何能访问到该资源。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。
  简单地说，只要能唯一标识资源的就是 URI，在 URI 的基础上**给出其资源的访问方式**的就是 URL。
  

- Q：为什么 fidder，charles 能抓到你的包【抓取数据包的过程】？

  A：[答案解析](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esx9xt/)


- Q：如果你访问一个网站很慢，怎么排查和解决

  A：[答案解析](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/es5hhr/)

- Q：其它协议？

  A：[答案解析](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/es5cjs/)

- Q：网页解析全过程【用户输入网址到显示对应页面的全过程】？

  A：![](https://pic.leetcode-cn.com/1612459029-slhrTZ-%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

  [答案解析](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/es94bd/)