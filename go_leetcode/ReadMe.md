# algorithm learning
-   算法是用于解决某一类问题的公式和思想
-   评判标准：时间复杂度和空间复杂度

# 数据结构
- 主要数据结构分为五类：按照线性结构和非线性结构划分
-   需要注意的是，**数据结构并不等于存储结构** 非线性结构依旧可以使用数组存储，并且绝大多数都是存储在数组里面的
-   数据结构主要指的是逻辑结构，而存储结构主要是指物理结构，主要就是数组和链表 
    
-   **线性**数据结构：数组、栈、队列
-   **非线性**数据结构：树、图
-   **other**：哈希、堆、字符串、跳表、哈希链表、位图
-   数据结构的特点无非就是增删改查4种情况

## 数组
-   数组是在程序设计 中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。
-   特点：线性表的实现方式之一，元素都是连续存储的，每个元素占用相同的内存

    eg：['oranges', 'apples', 'bananas', 'pears', 'tomatoes']

    ![](https://pic.leetcode-cn.com/65312e6dff56fc0c2ffad8752d6ca08da9bb7ec03211619754abd407e05147e8-2.png)
    
    !在具体的实现方式中，C++和Java每个元素结构必须保持一样的数据结构

    ！！但是Python中可以是不同的数据类型

-   题目类型：

    1、矩形转置：注意行列可能是不同的所以不一样能进行原地转置
    
    2、求众数：采用摩尔投票法，也被称为多数投票法，解决众数问题
        
        2.1 对抗阶段：分属两个候选人的票数进行两两对抗抵消
        
        2.2 计数阶段：计算对抗结果中最后留下的候选人票数是否有效


##  动态数组

## 栈
-   输出顺序和输入顺序相反，所以栈通常用于对历史的回溯，也就是逆流而上追溯历史。
-   例如实现递归的逻辑
-   栈还有一个著名的应用场景是面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面
![](https://pic.leetcode-cn.com/422c593838e22dc0f5638df6cd5bb4cd12cc5b405dd4546f288210d2451b168a-image.png)
    


## 队列
-   队列的输出顺序和输入顺序相同，所以队列通常用于对「历史」的回放，也就是按照「历史」顺序，把「历史」重演一遍。
-   例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。 
    再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的。

## 哈希表
-   散列表也叫作 哈希表（hash table），这种数据结构提供了 键（Key）和 值（Value）的映射关系。只要给出一个 Key，就可以高效查找到它所匹配的 Value，时间复杂度接近于 O(1)O(1)。
-   解决冲突的两种方法：开放寻址法、链表法
-   扩展：**红黑树**：[参考网址](https://www.jianshu.com/p/e136ec79235c)


## 树
-   在数据结构中，树的定义如下：树（tree）是 n(n \geq 0)n(n≥0)个节点的有限集。当 n = 0n=0 时，称为空树。在任意一个非空树中，有如下特点。
    
    有且仅有一个特定的称为根的节点。
    
    当 n>1n>1 时，其余节点可分为 m(m>0)m(m>0)个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。
    
    下面这张图，就是一个标准的树结构。

![](https://pic.leetcode-cn.com/a03fd322fa360e64fcd0cb63d1c54e0e2c7f1513ba50c7104ff76f2459e68f39-image.png)

###   二叉树
-   遍历：主要有四种，前序遍历、中序遍历、后序遍历、层序遍历。前三种是深度遍历、最后是广度遍历
-   以根节点来判断是前序后序还是中序遍历
-   二叉树用递归方式来实现前序、中序、后序遍历，是最为自然的方式，因此代码也非常简单。
-   这 3 种遍历方式的区别，仅仅是输出的执行位置不同：前序遍历的输出在前，中序遍历的输出在中间，后序遍历的输出在最后。
-   深度优先遍历是借助栈实现了遍历
-   广度优先遍历借助队列实现了遍历

###  二叉堆
-   本质上是一种完全二叉树，主要分为两个类型
-   最大堆和最小堆
-   最大堆：最大堆的任何一个父节点的值，都 大于或等于 它左、右孩子节点的值。】
    ![](https://pic.leetcode-cn.com/09bac735648e52f9314bb098a29fa46f5ddf6306c9785f2c608ec86e4acc74dc-image.png)
-   最小堆：最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。
    ![](https://pic.leetcode-cn.com/d4f91b0691c64a085e0c960d03540938ee01a06856947fbbbf95ff7127642744-image.png)
    
-   操作：
    
    1、插入节点
    
    2、删除节点
    
    3、构建二叉堆

### 优先队列
-   最大优先队列：无论入队顺序如何，都是当前最大的元素优先出队
-   最小优先队列：无论入队顺序如何，都是当前最小的元素优先出队
-   

## 排序
-   时间复杂度为O(n2)

    冒泡排序、选择排序、插入排序、希尔排序
    
-   时间复杂度为O(nlogn)的排序算法

    快速排序、归并排序、堆排序
    
-   时间复杂度为线性的排序算法

    计数排序、桶排序、基数排序    
    
### 冒泡排序
-   [web](https://leetcode-cn.com/leetbook/read/journey-of-algorithm/5rxj8i/)
-   扩充：鸡尾酒排序：
    
    冒泡排序的每一个元素都可以像小气泡一样，根据自身大小，一点一点地向着数组的一侧移动。算法的每一轮都是 从左到右来比较元素，进行单向的位置交换的。
    
    那么鸡尾酒排序做了怎样的优化呢？
    
    鸡尾酒排序的元素比较和交换过程是**双向**的。
    
### 快速排序
-    在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分
![](https://pic.leetcode-cn.com/5736c868108b6e9d183759eb620905e71f289e745d50a6a7147ef0434c8effe4-image.png)
-   实现方法：主要有两种

    双边循环、单边循环法、以及不常用的递归循环法


### 堆排序

-   步骤：
    
    1.把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。
    
    2.循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。
    
-   堆排序和快速排序的区别：
![](https://pic.leetcode-cn.com/c5aa2c35d580454d884e4f398b1446f4f1de9ce1aa9d6b08bff6ebef25b394b2-image.png)   


### 计数排序

### 桶排序

### 小结

![](https://pic.leetcode-cn.com/18abb46becb47a9169e4281e3675ac92a39a9faab5e2ccf50f4b649d2e3cd406-image.png)